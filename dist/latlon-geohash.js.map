{"version":3,"sources":["../src/latlon-geohash.js"],"names":["Geohash","base32","encode","lat","lon","precision","p","hash","posn","decode","Number","isNaN","Error","idx","bit","evenBit","geohash","latMin","latMax","lonMin","lonMax","length","lonMid","latMid","charAt","bounds","sw","ne","toFixed","Math","floor","log","LN10","toLowerCase","i","chr","indexOf","n","bitN","adjacent","direction","neighbour","s","e","w","border","lastCh","slice","parent","type","neighbours","module","exports"],"mappings":"AAAA;AACA;AACA;;AAEA;;AAGA;;;;;;;;;;;;;AAKIA,mB,GAAU,E;;;AAEd;AACAA,oBAAQC,MAAR,GAAiB,kCAAjB;;AAEA;;;;;;;;;;;;;AAaAD,oBAAQE,MAAR,GAAiB,UAASC,GAAT,EAAcC,GAAd,EAAmBC,SAAnB,EAA8B;AAC3C;AACA,oBAAI,OAAOA,SAAP,IAAoB,WAAxB,EAAqC;AACjC;AACA,yBAAK,IAAIC,IAAE,CAAX,EAAcA,KAAG,EAAjB,EAAqBA,GAArB,EAA0B;AACtB,4BAAIC,OAAOP,QAAQE,MAAR,CAAeC,GAAf,EAAoBC,GAApB,EAAyBE,CAAzB,CAAX;AACA,4BAAIE,OAAOR,QAAQS,MAAR,CAAeF,IAAf,CAAX;AACA,4BAAIC,KAAKL,GAAL,IAAUA,GAAV,IAAiBK,KAAKJ,GAAL,IAAUA,GAA/B,EAAoC,OAAOG,IAAP;AACvC;AACDF,gCAAY,EAAZ,CAPiC,CAOjB;AACnB;;AAEDF,sBAAMO,OAAOP,GAAP,CAAN;AACAC,sBAAMM,OAAON,GAAP,CAAN;AACAC,4BAAYK,OAAOL,SAAP,CAAZ;;AAEA,oBAAIM,MAAMR,GAAN,KAAcQ,MAAMP,GAAN,CAAd,IAA4BO,MAAMN,SAAN,CAAhC,EAAkD,MAAM,IAAIO,KAAJ,CAAU,iBAAV,CAAN;;AAElD,oBAAIC,MAAM,CAAV,CAlB2C,CAkB9B;AACb,oBAAIC,MAAM,CAAV,CAnB2C,CAmB9B;AACb,oBAAIC,UAAU,IAAd;AACA,oBAAIC,UAAU,EAAd;;AAEA,oBAAIC,SAAU,CAAC,EAAf;AAAA,oBAAmBC,SAAU,EAA7B;AACA,oBAAIC,SAAS,CAAC,GAAd;AAAA,oBAAmBC,SAAS,GAA5B;;AAEA,uBAAOJ,QAAQK,MAAR,GAAiBhB,SAAxB,EAAmC;AAC/B,wBAAIU,OAAJ,EAAa;AACT;AACA,4BAAIO,SAAS,CAACH,SAASC,MAAV,IAAoB,CAAjC;AACA,4BAAIhB,OAAOkB,MAAX,EAAmB;AACfT,kCAAMA,MAAI,CAAJ,GAAQ,CAAd;AACAM,qCAASG,MAAT;AACH,yBAHD,MAGO;AACHT,kCAAMA,MAAI,CAAV;AACAO,qCAASE,MAAT;AACH;AACJ,qBAVD,MAUO;AACH;AACA,4BAAIC,SAAS,CAACN,SAASC,MAAV,IAAoB,CAAjC;AACA,4BAAIf,OAAOoB,MAAX,EAAmB;AACfV,kCAAMA,MAAI,CAAJ,GAAQ,CAAd;AACAI,qCAASM,MAAT;AACH,yBAHD,MAGO;AACHV,kCAAMA,MAAI,CAAV;AACAK,qCAASK,MAAT;AACH;AACJ;AACDR,8BAAU,CAACA,OAAX;;AAEA,wBAAI,EAAED,GAAF,IAAS,CAAb,EAAgB;AACZ;AACAE,mCAAWhB,QAAQC,MAAR,CAAeuB,MAAf,CAAsBX,GAAtB,CAAX;AACAC,8BAAM,CAAN;AACAD,8BAAM,CAAN;AACH;AACJ;;AAED,uBAAOG,OAAP;AACH,aA3DD;;AA8DA;;;;;;;;;;;AAWAhB,oBAAQS,MAAR,GAAiB,UAASO,OAAT,EAAkB;;AAE/B,oBAAIS,SAASzB,QAAQyB,MAAR,CAAeT,OAAf,CAAb,CAF+B,CAEO;AACtC;;AAEA,oBAAIC,SAASQ,OAAOC,EAAP,CAAUvB,GAAvB;AAAA,oBAA4BgB,SAASM,OAAOC,EAAP,CAAUtB,GAA/C;AACA,oBAAIc,SAASO,OAAOE,EAAP,CAAUxB,GAAvB;AAAA,oBAA4BiB,SAASK,OAAOE,EAAP,CAAUvB,GAA/C;;AAEA;AACA,oBAAID,MAAM,CAACc,SAASC,MAAV,IAAkB,CAA5B;AACA,oBAAId,MAAM,CAACe,SAASC,MAAV,IAAkB,CAA5B;;AAEA;AACAjB,sBAAMA,IAAIyB,OAAJ,CAAYC,KAAKC,KAAL,CAAW,IAAED,KAAKE,GAAL,CAASb,SAAOD,MAAhB,IAAwBY,KAAKG,IAA1C,CAAZ,CAAN;AACA5B,sBAAMA,IAAIwB,OAAJ,CAAYC,KAAKC,KAAL,CAAW,IAAED,KAAKE,GAAL,CAASX,SAAOD,MAAhB,IAAwBU,KAAKG,IAA1C,CAAZ,CAAN;;AAEA,uBAAO,EAAE7B,KAAKO,OAAOP,GAAP,CAAP,EAAoBC,KAAKM,OAAON,GAAP,CAAzB,EAAP;AACH,aAjBD;;AAoBA;;;;;;;AAOAJ,oBAAQyB,MAAR,GAAiB,UAAST,OAAT,EAAkB;AAC/B,oBAAIA,QAAQK,MAAR,KAAmB,CAAvB,EAA0B,MAAM,IAAIT,KAAJ,CAAU,iBAAV,CAAN;;AAE1BI,0BAAUA,QAAQiB,WAAR,EAAV;;AAEA,oBAAIlB,UAAU,IAAd;AACA,oBAAIE,SAAU,CAAC,EAAf;AAAA,oBAAmBC,SAAU,EAA7B;AACA,oBAAIC,SAAS,CAAC,GAAd;AAAA,oBAAmBC,SAAS,GAA5B;;AAEA,qBAAK,IAAIc,IAAE,CAAX,EAAcA,IAAElB,QAAQK,MAAxB,EAAgCa,GAAhC,EAAqC;AACjC,wBAAIC,MAAMnB,QAAQQ,MAAR,CAAeU,CAAf,CAAV;AACA,wBAAIrB,MAAMb,QAAQC,MAAR,CAAemC,OAAf,CAAuBD,GAAvB,CAAV;AACA,wBAAItB,OAAO,CAAC,CAAZ,EAAe,MAAM,IAAID,KAAJ,CAAU,iBAAV,CAAN;;AAEf,yBAAK,IAAIyB,IAAE,CAAX,EAAcA,KAAG,CAAjB,EAAoBA,GAApB,EAAyB;AACrB,4BAAIC,OAAOzB,OAAOwB,CAAP,GAAW,CAAtB;AACA,4BAAItB,OAAJ,EAAa;AACT;AACA,gCAAIO,SAAS,CAACH,SAAOC,MAAR,IAAkB,CAA/B;AACA,gCAAIkB,QAAQ,CAAZ,EAAe;AACXnB,yCAASG,MAAT;AACH,6BAFD,MAEO;AACHF,yCAASE,MAAT;AACH;AACJ,yBARD,MAQO;AACH;AACA,gCAAIC,SAAS,CAACN,SAAOC,MAAR,IAAkB,CAA/B;AACA,gCAAIoB,QAAQ,CAAZ,EAAe;AACXrB,yCAASM,MAAT;AACH,6BAFD,MAEO;AACHL,yCAASK,MAAT;AACH;AACJ;AACDR,kCAAU,CAACA,OAAX;AACH;AACJ;;AAED,oBAAIU,SAAS;AACTC,wBAAI,EAAEvB,KAAKc,MAAP,EAAeb,KAAKe,MAApB,EADK;AAETQ,wBAAI,EAAExB,KAAKe,MAAP,EAAed,KAAKgB,MAApB;AAFK,iBAAb;;AAKA,uBAAOK,MAAP;AACH,aA3CD;;AA8CA;;;;;;;;AAQAzB,oBAAQuC,QAAR,GAAmB,UAASvB,OAAT,EAAkBwB,SAAlB,EAA6B;AAC5C;;AAEAxB,0BAAUA,QAAQiB,WAAR,EAAV;AACAO,4BAAYA,UAAUP,WAAV,EAAZ;;AAEA,oBAAIjB,QAAQK,MAAR,KAAmB,CAAvB,EAA0B,MAAM,IAAIT,KAAJ,CAAU,iBAAV,CAAN;AAC1B,oBAAI,OAAOwB,OAAP,CAAeI,SAAf,KAA6B,CAAC,CAAlC,EAAqC,MAAM,IAAI5B,KAAJ,CAAU,mBAAV,CAAN;;AAErC,oBAAI6B,YAAY;AACZJ,uBAAG,CAAE,kCAAF,EAAsC,kCAAtC,CADS;AAEZK,uBAAG,CAAE,kCAAF,EAAsC,kCAAtC,CAFS;AAGZC,uBAAG,CAAE,kCAAF,EAAsC,kCAAtC,CAHS;AAIZC,uBAAG,CAAE,kCAAF,EAAsC,kCAAtC;AAJS,iBAAhB;AAMA,oBAAIC,SAAS;AACTR,uBAAG,CAAE,MAAF,EAAc,UAAd,CADM;AAETK,uBAAG,CAAE,MAAF,EAAc,UAAd,CAFM;AAGTC,uBAAG,CAAE,UAAF,EAAc,MAAd,CAHM;AAITC,uBAAG,CAAE,UAAF,EAAc,MAAd;AAJM,iBAAb;;AAOA,oBAAIE,SAAS9B,QAAQ+B,KAAR,CAAc,CAAC,CAAf,CAAb,CAtB4C,CAsBT;AACnC,oBAAIC,SAAShC,QAAQ+B,KAAR,CAAc,CAAd,EAAiB,CAAC,CAAlB,CAAb,CAvB4C,CAuBT;;AAEnC,oBAAIE,OAAOjC,QAAQK,MAAR,GAAiB,CAA5B;;AAEA;AACA,oBAAIwB,OAAOL,SAAP,EAAkBS,IAAlB,EAAwBb,OAAxB,CAAgCU,MAAhC,KAA2C,CAAC,CAA5C,IAAiDE,WAAW,EAAhE,EAAoE;AAChEA,6BAAShD,QAAQuC,QAAR,CAAiBS,MAAjB,EAAyBR,SAAzB,CAAT;AACH;;AAED;AACA,uBAAOQ,SAAShD,QAAQC,MAAR,CAAeuB,MAAf,CAAsBiB,UAAUD,SAAV,EAAqBS,IAArB,EAA2Bb,OAA3B,CAAmCU,MAAnC,CAAtB,CAAhB;AACH,aAlCD;;AAqCA;;;;;;;AAOA9C,oBAAQkD,UAAR,GAAqB,UAASlC,OAAT,EAAkB;AACnC,uBAAO;AACH,yBAAMhB,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CADH;AAEH,0BAAMhB,QAAQuC,QAAR,CAAiBvC,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CAAjB,EAAiD,GAAjD,CAFH;AAGH,yBAAMhB,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CAHH;AAIH,0BAAMhB,QAAQuC,QAAR,CAAiBvC,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CAAjB,EAAiD,GAAjD,CAJH;AAKH,yBAAMhB,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CALH;AAMH,0BAAMhB,QAAQuC,QAAR,CAAiBvC,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CAAjB,EAAiD,GAAjD,CANH;AAOH,yBAAMhB,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CAPH;AAQH,0BAAMhB,QAAQuC,QAAR,CAAiBvC,QAAQuC,QAAR,CAAiBvB,OAAjB,EAA0B,GAA1B,CAAjB,EAAiD,GAAjD;AARH,iBAAP;AAUH,aAXD;;AAcA;AACA,gBAAI,OAAOmC,MAAP,IAAiB,WAAjB,IAAgCA,OAAOC,OAA3C,EAAoDD,OAAOC,OAAP,GAAiBpD,OAAjB,C,CAA0B","file":"latlon-geohash.js","sourcesContent":["/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n/* Geohash encoding/decoding and associated functions   (c) Chris Veness 2014-2016 / MIT Licence  */\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\n\n'use strict';\n\n\n/**\n * Geohash encode, decode, bounds, neighbours.\n *\n * @namespace\n */\nvar Geohash = {};\n\n/* (Geohash-specific) Base32 map */\nGeohash.base32 = '0123456789bcdefghjkmnpqrstuvwxyz';\n\n/**\n * Encodes latitude/longitude to geohash, either to specified precision or to automatically\n * evaluated precision.\n *\n * @param   {number} lat - Latitude in degrees.\n * @param   {number} lon - Longitude in degrees.\n * @param   {number} [precision] - Number of characters in resulting geohash.\n * @returns {string} Geohash of supplied latitude/longitude.\n * @throws  Invalid geohash.\n *\n * @example\n *     var geohash = Geohash.encode(52.205, 0.119, 7); // geohash: 'u120fxw'\n */\nGeohash.encode = function(lat, lon, precision) {\n    // infer precision?\n    if (typeof precision == 'undefined') {\n        // refine geohash until it matches precision of supplied lat/lon\n        for (var p=1; p<=12; p++) {\n            var hash = Geohash.encode(lat, lon, p);\n            var posn = Geohash.decode(hash);\n            if (posn.lat==lat && posn.lon==lon) return hash;\n        }\n        precision = 12; // set to maximum\n    }\n\n    lat = Number(lat);\n    lon = Number(lon);\n    precision = Number(precision);\n\n    if (isNaN(lat) || isNaN(lon) || isNaN(precision)) throw new Error('Invalid geohash');\n\n    var idx = 0; // index into base32 map\n    var bit = 0; // each char holds 5 bits\n    var evenBit = true;\n    var geohash = '';\n\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    while (geohash.length < precision) {\n        if (evenBit) {\n            // bisect E-W longitude\n            var lonMid = (lonMin + lonMax) / 2;\n            if (lon >= lonMid) {\n                idx = idx*2 + 1;\n                lonMin = lonMid;\n            } else {\n                idx = idx*2;\n                lonMax = lonMid;\n            }\n        } else {\n            // bisect N-S latitude\n            var latMid = (latMin + latMax) / 2;\n            if (lat >= latMid) {\n                idx = idx*2 + 1;\n                latMin = latMid;\n            } else {\n                idx = idx*2;\n                latMax = latMid;\n            }\n        }\n        evenBit = !evenBit;\n\n        if (++bit == 5) {\n            // 5 bits gives us a character: append it and start over\n            geohash += Geohash.base32.charAt(idx);\n            bit = 0;\n            idx = 0;\n        }\n    }\n\n    return geohash;\n};\n\n\n/**\n * Decode geohash to latitude/longitude (location is approximate centre of geohash cell,\n *     to reasonable precision).\n *\n * @param   {string} geohash - Geohash string to be converted to latitude/longitude.\n * @returns {{lat:number, lon:number}} (Center of) geohashed location.\n * @throws  Invalid geohash.\n *\n * @example\n *     var latlon = Geohash.decode('u120fxw'); // latlon: { lat: 52.205, lon: 0.1188 }\n */\nGeohash.decode = function(geohash) {\n\n    var bounds = Geohash.bounds(geohash); // <-- the hard work\n    // now just determine the centre of the cell...\n\n    var latMin = bounds.sw.lat, lonMin = bounds.sw.lon;\n    var latMax = bounds.ne.lat, lonMax = bounds.ne.lon;\n\n    // cell centre\n    var lat = (latMin + latMax)/2;\n    var lon = (lonMin + lonMax)/2;\n\n    // round to close to centre without excessive precision: ⌊2-log10(Δ°)⌋ decimal places\n    lat = lat.toFixed(Math.floor(2-Math.log(latMax-latMin)/Math.LN10));\n    lon = lon.toFixed(Math.floor(2-Math.log(lonMax-lonMin)/Math.LN10));\n\n    return { lat: Number(lat), lon: Number(lon) };\n};\n\n\n/**\n * Returns SW/NE latitude/longitude bounds of specified geohash.\n *\n * @param   {string} geohash - Cell that bounds are required of.\n * @returns {{sw: {lat: number, lon: number}, ne: {lat: number, lon: number}}}\n * @throws  Invalid geohash.\n */\nGeohash.bounds = function(geohash) {\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n\n    geohash = geohash.toLowerCase();\n\n    var evenBit = true;\n    var latMin =  -90, latMax =  90;\n    var lonMin = -180, lonMax = 180;\n\n    for (var i=0; i<geohash.length; i++) {\n        var chr = geohash.charAt(i);\n        var idx = Geohash.base32.indexOf(chr);\n        if (idx == -1) throw new Error('Invalid geohash');\n\n        for (var n=4; n>=0; n--) {\n            var bitN = idx >> n & 1;\n            if (evenBit) {\n                // longitude\n                var lonMid = (lonMin+lonMax) / 2;\n                if (bitN == 1) {\n                    lonMin = lonMid;\n                } else {\n                    lonMax = lonMid;\n                }\n            } else {\n                // latitude\n                var latMid = (latMin+latMax) / 2;\n                if (bitN == 1) {\n                    latMin = latMid;\n                } else {\n                    latMax = latMid;\n                }\n            }\n            evenBit = !evenBit;\n        }\n    }\n\n    var bounds = {\n        sw: { lat: latMin, lon: lonMin },\n        ne: { lat: latMax, lon: lonMax },\n    };\n\n    return bounds;\n};\n\n\n/**\n * Determines adjacent cell in given direction.\n *\n * @param   geohash - Cell to which adjacent cell is required.\n * @param   direction - Direction from geohash (N/S/E/W).\n * @returns {string} Geocode of adjacent cell.\n * @throws  Invalid geohash.\n */\nGeohash.adjacent = function(geohash, direction) {\n    // based on github.com/davetroy/geohash-js\n\n    geohash = geohash.toLowerCase();\n    direction = direction.toLowerCase();\n\n    if (geohash.length === 0) throw new Error('Invalid geohash');\n    if ('nsew'.indexOf(direction) == -1) throw new Error('Invalid direction');\n\n    var neighbour = {\n        n: [ 'p0r21436x8zb9dcf5h7kjnmqesgutwvy', 'bc01fg45238967deuvhjyznpkmstqrwx' ],\n        s: [ '14365h7k9dcfesgujnmqp0r2twvyx8zb', '238967debc01fg45kmstqrwxuvhjyznp' ],\n        e: [ 'bc01fg45238967deuvhjyznpkmstqrwx', 'p0r21436x8zb9dcf5h7kjnmqesgutwvy' ],\n        w: [ '238967debc01fg45kmstqrwxuvhjyznp', '14365h7k9dcfesgujnmqp0r2twvyx8zb' ],\n    };\n    var border = {\n        n: [ 'prxz',     'bcfguvyz' ],\n        s: [ '028b',     '0145hjnp' ],\n        e: [ 'bcfguvyz', 'prxz'     ],\n        w: [ '0145hjnp', '028b'     ],\n    };\n\n    var lastCh = geohash.slice(-1);    // last character of hash\n    var parent = geohash.slice(0, -1); // hash without last character\n\n    var type = geohash.length % 2;\n\n    // check for edge-cases which don't share common prefix\n    if (border[direction][type].indexOf(lastCh) != -1 && parent !== '') {\n        parent = Geohash.adjacent(parent, direction);\n    }\n\n    // append letter for direction to parent\n    return parent + Geohash.base32.charAt(neighbour[direction][type].indexOf(lastCh));\n};\n\n\n/**\n * Returns all 8 adjacent cells to specified geohash.\n *\n * @param   {string} geohash - Geohash neighbours are required of.\n * @returns {{n,ne,e,se,s,sw,w,nw: string}}\n * @throws  Invalid geohash.\n */\nGeohash.neighbours = function(geohash) {\n    return {\n        'n':  Geohash.adjacent(geohash, 'n'),\n        'ne': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'e'),\n        'e':  Geohash.adjacent(geohash, 'e'),\n        'se': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'e'),\n        's':  Geohash.adjacent(geohash, 's'),\n        'sw': Geohash.adjacent(Geohash.adjacent(geohash, 's'), 'w'),\n        'w':  Geohash.adjacent(geohash, 'w'),\n        'nw': Geohash.adjacent(Geohash.adjacent(geohash, 'n'), 'w'),\n    };\n};\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */\nif (typeof module != 'undefined' && module.exports) module.exports = Geohash; // CommonJS, node.js\n"]}